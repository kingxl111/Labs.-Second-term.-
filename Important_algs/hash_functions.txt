a, b, h(a), h(b)

Утверждения про хеш-функцию:

1) a == b => h(a) == h(b)

2) a != b !=> h(a) != h(b) 

3) h(a) == h(b) !=> a == b

4) h(a) != h(b) => a != b

Криптографическая хеш-функция 

Она должна иметь большое сжимающее множество 

CRC32 - НЕ ЯВЛЯЕТСЯ КРИПТОГРАФИЧЕСКОЙ ФУНКЦИЕЙ, так как можно с легкостью перебрать 4 млрд вариантов

MD5 - уже тоже не очень подходит для понятия хеш-функции

SHA256
SHA512

Где это применяется?
Насчет паролей: если в базе данных храним пользователей, надо хранить для них логин и пароль.
Если кто-то залезет в базу данных, то пароли окажутся в открытом доступе.
Хранить пароль в открытом виде - недопустимо!
Надо использовать хеширование!

Пользователь вводит пароль, от которого вычисляется хеш. 
При последующем входе от введенного пароля сравнивается хеш с хешом исходного пароля

Замедление алгоритма хеширования - это отличный способ защитить пароль


Если два пользователя используют один и тот же пароль, то хеши будут одинаковыми.

Для каждого пароля дописываем "соль". 
То есть у каждого пользователя будет разная хеш сумма, даже если пароли совпадут(или хеши от них), то хеш-сумма будет всё равно отличаться


Есть симметричная и асимметричная криптография.
Симметричная криптография: ключ шифрования и дешифрования одинаковые

c = crypt(k, t)
t = decrypt(k, c)

Асимметричное шифрование: 
Генерируем два разных ключа: один для шифрования, другой - для дешифровки

c = crypt(Kpub, t)
t = decrypt(Kpriv, c)

Kpub - публичный ключ, Kpriv - приватный ключ

То, что зашифровано публичным ключом, расшифровывается приватным. То, что зашифровано приватным ключом, расшифровывается публичным.
То есть один ключ мы держим в секрете.

Алгоритмы ассиметричного шифрования очень медленные

То есть криптографическое хеширование используется для составления электронной подписи, для хранения паролей.




-----------------------------------------------------------------------------------------------
Теперь хеш таблицы

Map<k,v> m; - ставим некоторому ключу в соответствие некоторое значение 

m.put(k1, val1);
val1 = m.get(k1);

Нужно придумать хеш-функцию, которая возвращает некоторое число

Выделим некотоый буфер, размер которого будет изрядно больше, чем количество элементов, которые мы можем в этот буфер положить
h1 = h(k1)
Создаем объект, который будет содержать 3 вещи: k1, v1, h1
Вычисляем индекс, например, при помощи h1 % cap, где cap - длина буфера
i1 = h1 % cap;

Теперь берем второй объект и кладем его по индексу i2. И так далее...










